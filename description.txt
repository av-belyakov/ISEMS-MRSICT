Программное средство «Управление записями структурированной информации о компьютерных угрозах» Managing Records of Structured Information 
About Computer Threats (ISEMS-MRSICT).

Описание. Функциональные возможности.

Введение
    Подсистема  ISEMS-MRSICT является частью системы управления событиями информационной безопасности Information Security Event Management System (ISEMS) и
была создана для решения следующих задач: 
1. Прием информации о компьютерных угрозах, получаемой как от стороннего программного обеспечения, методом межсетевого взаимодействия, так и от оператора 
подсистемы ISEMS-MRSICT по средствам обмена JSON документами формат и структура которых приводится ниже.
2. Структурирование и обогащение полученной информации дополнительными данными, путем обмена данными со сторонними информационными системами или
ресурсами. Запись принятой информации в подсистему обеспечивающую долговременное хранение.
3. Формирование JSON документов, формат и структура которых приводится ниже, содержащих информацию о компьютерных угрозах, источниках получения информации, 
результатах её статистической и аналитической обработки пригодных для представления её в графическом пользовательском интерфейсе в виде таблиц, 
графических диаграмм, счетчиков и т. д.
4. Обеспечение полного жизненного цикла информации о компьютерных угрозах, отслеживание её состояния и изменение, помощь в принятии решения при её 
обработке, фиксирование результатов обработки.
5. Реализация гибкого поиска информации о компьютерных угрозах в подсистеме долговременного хранения. Вывод результатов поиска в виде JSON документов, 
формат и структура которых приводится ниже, для их последующем представлении в графическом пользовательском интерфейсе в наиболее подходящем для 
восприятия виде. 
5. Подготовка итоговых документов формируемых по результатам обработки обнаруженных компьютерных угроз на основе заранее заложенных шаблонов.
6. Создание отчетов формируемых на основе информации об обнаруженных компьютерных угрозах и опираясь на заданные оператором ключевые поля.
7. Двух стороннее взаимодействие с другими модулями и подсистемами системы ISEMS для обогащения дополнительными данными имеющейся информации или 
выполнения дополнительных действий, позволяющих ускорить или упростить обработку информации о компьютерных угрозах.

Функциональные возможности

Структура JSON документов используемых для взаимодействия подсистемы ISEMS-MRSICT с графическим пользовательским интерфейсом ISEMS-UI
    1. Структура и формат JSON объектов, содержащих информациионные сообщения, отправляемые подсистемой ISEMS-MRSICT в ответ на действия пользователя, 
выполняемые в графическом пользовательском интерфейсе ISEMS-UI. Пример сообщения:
{
    task_id: STRING // уникальный ID задачи (для сообщений подобного типа данное поле является необязательным)
    section: STRING // секция обработки данных, например, "handling stix object" (обработка объектов STIX), "handling search requests" (обработка 
                    // поисковых запросов) и т.д. (для сообщений подобного типа данное поле является необязательным)
    is_successful: BOOL // индикатор сигнализирующий об успешности выполняемой задачи (если тип сообщений 'success' или 'info', тогда TRUE)
    information_message: {
        msg_type: STRING // тип сообщения (всего четыре типа 'success', 'info', 'warning' и 'danger')
        msg: STRING // информационное сообщение вида: 'Секция: '<секция обработки>'. Тип: '<тип выполняемого действия>'. Действие: '<успешность 
                    // выполненного действия>'. <подробное описание если есть>'
    }
}

    2. Структура и формат JSON документов, получаемых от графического пользовательского интерфейса ISEMS-UI и содержащих STIX объекты с информацией, 
которую необходимо ДОБАВИТЬ или ОБНОВИТЬ в системе долговременного хранения. Пример сообщения:
{
    task_id: STRING // уникальный ID задачи (обязательное значение)
    section: "handling stix object" // секция обработки данных (обязательное значение, для данного типа действия ТОЛЬКО "handling stix object")
    user_name_generated_task: STRING // имя пользователя сгенерировавшего задачу (необязательный параметр)
    request_details: [ <any STIX objects> ] // массив объектов структура и формат которых соответствует DO STIX, CO STIX или RO STIX
}

    3. Структура и формат JSON документа, получаемого от графического пользовательского интерфейса ISEMS-UI и содержащего поисковый запрос, направленный
на поиск информации в коллекции STIX объектов. ВНИМАНИЕ, если параметр 'paginate_parameters' отсутствует или хотя бы один из параметров 'max_part_size' или
'current_part_number' содержит '0', то считается что, такой запрос выполняется ТОЛЬКО с целью получить ОБЩЕЕ КОЛИЧЕСТВО найденных элементов. Ответ на
такой запрос будет содержать общее количество найденных элементов и не более. Пример запроса:
{
    task_id: STRING // уникальный ID задачи (обязательное значение)
    section: "handling search requests" // секция обработки данных (обязательное значение, для данного типа действия ТОЛЬКО "handling search requests")
    user_name_generated_task: STRING // имя пользователя сгенерировавшего задачу (необязательный параметр)
    request_details: {
        collection_name: STRING // наименование коллекции документов. Для поиска STIX объектов collection_name = "stix object"
        //параметры разбиения на страницы
        
        paginate_parameters: {
            max_part_size: INT // размер части, то есть максимальное количество найденных элементов, которое может содержаться в одном ответе (данное значение не должно быть меньше '1')
            current_part_number: INT // номер текущей части (данное значение не должно быть меньше '1')
        }

        sortable_field: STRING // параметр в котором можно указать значение, по которому будет выполнятся сортировка полей. Параметр должен содержать
                               // одно из следующих значений: "document_type", "data_created", "data_modified", "data_first_seen", "data_last_seen", 
                               // "ipv4", "ipv6", "country". Если данное поле пустое, то сортировка будет выполнятся по свойству ObjectId БД MongoDB

        search_parameters: {} // параметры поиска (для разных коллекций параметры поиска отличаются)

        /* параметры поиска для коллекции типа "stix object" */
        search_parameters: {
            // между параметрами "id_documents", "type_documents", "created", "modified", "created_by_ref" используется логика "И"
            documents_id: [STRING] // список идентификаторов документов STIX (если данный параметр СОДЕРЖИТ список идентификаторов то остальные параметры
                                   // НЕ УЧИТЫВАЮТСЯ в ходе выполнения поискового запроса)
            documents_type: [STRING] // наименования типа документов STIX объектов, название которых содержится в поле "type" любого STIX документа
            
            /* если заполнены оба поля 'created' и 'modified' то тогда для поиска по данным из обоих полей работает логика "ИЛИ" */
            /* время создания объекта, в формате "2016-05-12T08:17:27.000Z" (только для DO или RO STIX) */
            created: {
                    start: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                    end: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                }
            /* время модификации объекта, в формате "2016-05-12T08:17:27.000Z" (только для DO или RO STIX) */
            modified: {
                    start: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                    end: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                } 
            created_by_ref: STRING // содержит идентификатор источника создавшего данный объект (только для DO STIX)

            /* specific_search_fields содержит специфичные поля объектов STIX (если для поиска используются НЕСКОЛЬКО таких объектов то срабатывает логика "ИЛИ")
            если в объекте заполнены несколько полей то между ними работает логика "И", со всеми полями кроме полей даты.
            Для поля "Value" выполняется проверка на соответствия одному из следующих типов значений: "domain-name", "email-addr", "ipv4-addr", 
            "ipv6-addr" или "url" */

            specific_search_fields: [
                {
                    name: STRING // имя используемое для идентификации искомого типа
                    aliases: [STRING] // альтернативные имена
                    /* интервал времени когда информация была обнаружена впервые */
                    first_seen: {
                        start: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                        end: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                    },
                    /* интервал времени когда информация была обнаружена в последний раз */
                    last_seen: {
                        start: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                        end: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                    },
                    /* равно или больше чем заданное пользователем время, когда отчет был опубликован */
                    published: STRING типа time // в формате "2016-05-12T08:17:27.000Z"
                    roles: [STRING] // список ролей
                    country: STRING // наименование страны
                    city: STRING // наименование города
                    number_autonomous_system: INT // номер для идентификации Автономной системы
                    value: [STRING] // может содержать какое либо из следующих типов значений: "domain-name", "email-addr", "ipv4-addr", 
                                       "ipv6-addr" или "url". Или все эти значения в перемешку. Между значениями в поле 'Value' используется
                                       логика "ИЛИ".
                }
            ]
        }
    }
}

    4. Структура и формат JSON документа, отправляемого в графический пользовательский интерфейс ISEMS-UI и содержащего ответ на поисковый запрос или
вовсе БЕЗ параметра 'paginate_parameters' или с параметром 'paginate_parameters', но где, хотя бы один из параметров 'max_part_size' или 'current_part_number'
содержит '0'. Пример ответа:
{
    task_id: STRING // уникальный ID задачи (обязательное значение)
    section: "handling search requests" // секция обработки данных (обязательное значение, для данного типа действия ТОЛЬКО "handling search requests")
	is_successful: BOOL // был ли запрос успешно обработан (в данном случае TRUE)
	description: STRING // дополнительное описание (В ДАННОМ СЛУЧАЕ НЕ ЗАПОЛНЯЕТСЯ)
	information_message: { // информационное сообщение (НЕ ОБЯЗАТЕЛЬНО К ЗАПОЛНЕНИЮ)
        msg_type: STRING // тип информационного сообщения
        msg: STRING // информационное сообщение
    }
	additional_parameters: {
        number_documents_found: INT // общее количество найденных документов
    }
}

    5. Структура и формат JSON документа, отправляемого в графический пользовательский интерфейс ISEMS-UI и содержащего ответ на поисковый запрос с заданным
параметром 'paginate_parameters' и где ВСЕ значения параметров 'max_part_size' или 'current_part_number' больше '0'. Пример ответа:
{
    task_id: STRING // уникальный ID задачи (обязательное значение)
    section: "handling search requests" // секция обработки данных (обязательное значение, для данного типа действия ТОЛЬКО "handling search requests")
	is_successful: BOOL // был ли запрос успешно обработан (в данном случае TRUE)
	description: STRING // дополнительное описание (В ДАННОМ СЛУЧАЕ НЕ ЗАПОЛНЯЕТСЯ)
	information_message: { // информационное сообщение (НЕ ОБЯЗАТЕЛЬНО К ЗАПОЛНЕНИЮ)
        msg_type: STRING // тип информационного сообщения
        msg: STRING // информационное сообщение
    }
	additional_parameters: [ <any STIX objects> ] // массив объектов структура и формат которых соответствует DO STIX, CO STIX или RO STIX
}

    /* СОЗДАНИЕ СЕРТИФИКАТОВ И ПРИВАТНЫХ КЛЮЧЕЙ */
    Руководство https://hackware.ru/?p=12982 в помощь.
    
    1. Создаём корневой приватный ключ
        openssl genpkey -algorithm RSA -out rootCA.key

    2. Создаём самоподписный корневой сертификат
        openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.pem

    3. Создаём приватный ключ сертификата
        openssl genpkey -algorithm RSA -out isems_mrsict_private_key.pem

    4. Создаём файл с запросом на подпись сертификата (csr). Нужен ТОЛЬКО для создания сертификата сервера, потом его можно удалить
        openssl req -new -key isems_mrsict_private_key.pem -out mydomain.com.csr

    5. Создаём сертификат для сервера
        openssl x509 -req -in mydomain.com.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out isems_mrsict_cert.pem -days 1096 -sha256
